import os
import random
import datetime

from application.utils.constants import VOUCHERS_GENERAL_DIR
from application.database.psql_database import get_db_connection
from werkzeug.datastructures import FileStorage


class Activity:

    @staticmethod
    def register(owner_email: str, voucher: FileStorage, workload: int, kind: str, description: str, state: str, start_date: datetime.datetime, end_date: datetime.datetime):
        try:
            user_dir = owner_email.split("@")[0]

            if not os.path.exists(f'{VOUCHERS_GENERAL_DIR}/{user_dir}'):
                os.makedirs(f'{VOUCHERS_GENERAL_DIR}/{user_dir}')

            if not os.path.exists(f'{VOUCHERS_GENERAL_DIR}/{user_dir}/{voucher.filename}'):
                voucher_path = f'{VOUCHERS_GENERAL_DIR}/{user_dir}/{voucher.filename}'
            else:
                voucher_index = 1
                while True:
                    if not os.path.exists(f'{VOUCHERS_GENERAL_DIR}/{user_dir}/{voucher_index}-{voucher.filename}'):
                        voucher_path = f'{VOUCHERS_GENERAL_DIR}/{user_dir}/{voucher_index}-{voucher.filename}'
                        break
                    voucher_index += 1

            voucher.save(voucher_path)

            inset_query = " INSERT INTO activities_submitted (owner_email, kind, workload, state, description, voucher_path, start_date, end_date) "
            inset_query += f" VALUES ({owner_email}, {kind}, {workload}, {state}, {description}, {voucher_path}, {start_date}, {end_date}) "
            
            conn = get_db_connection()
            cur = conn.cursor()

            cur.execute(inset_query)

            conn.commit()
            cur.close()
            conn.close()

        except ValueError as e:
            raise (e)

    @staticmethod
    def assign(activity_id: int, reviewer_email: str, state: str):
        update_query = f" UPDATE activities_submitted SET reviewer_email = {reviewer_email}, state = {state} WHERE id = {activity_id} ; "
        select_query = f" SELECT acs.*, acm.workload_unity FROM activities_submitted acs JOIN activities_metrics acm ON acs.kind = acm.kind WHERE acs.id = {activity_id} "

        conn = get_db_connection()
        cur = conn.cursor()

        cur.execute(update_query)
        conn.commit()

        cur.execute(select_query)
        activity = cur.fetchone()

        cur.close()
        conn.close()

        return activity

    def validate(activity_id: int, state: str, computed_credits: int, justify: str):
        update_query = " UPDATE activities_submitted "
        if (computed_credits != None):
            update_query = f" SET state = '{state}', computed_credits = {computed_credits} WHERE id = {activity_id} "
        else:
            update_query = f" SET state = '{state}', justify = '{justify}' WHERE id = {activity_id} "

        select_query = f" SELECT acs.*, acm.workload_unity FROM activities_submitted acs JOIN activities_metrics acm ON acs.kind = acm.kind WHERE acs.id = {activity_id} "

        conn = get_db_connection()
        cur = conn.cursor()

        cur.execute(update_query)
        conn.commit()

        cur.execute(select_query)
        activity = cur.fetchone()

        cur.close()
        conn.close()

        return activity

    @staticmethod
    def find_all_subm_activities(page: int, size: int, sort: str, order: str):
        select_query = " SELECT acs.*, acm.workload_unity FROM activities_submitted acs JOIN activities_metrics acm ON acs.kind = acm.kind "
        if (sort and order):
            select_query += f" ORDER BY {sort} {order} "

        if (page != None and size != None):
            select_query += f" OFFSET {int(page) * int(size)} ROWS FETCH NEXT {size} ROWS ONLY "

        conn = get_db_connection()
        cur = conn.cursor()
        cur.execute(select_query)
        activities = cur.fetchall()
        conn.close()

        return activities

    @staticmethod
    def find_by_owner_or_state(owner_email: str, states: list, page: int, size: int, sort: str, order: str):
        select_query = " SELECT acs.*, acm.workload_unity FROM activities_submitted acs JOIN activities_metrics acm ON acs.kind = acm.kind "
        if owner_email:
            select_query = f" WHERE owner_email = '{owner_email}' "
       
        if owner_email and states:
            select_query += " AND "
        elif states:
            select_query = " WHERE "

        if states:
            for i, s in enumerate(states):
                if i == 0:
                    select_query += f" acs.state = '{s}' "
                else:
                    select_query += f" OR  acs.state = '{s}' "

        if (sort and order):
            select_query += f" ORDER BY {sort} {order} "
        
        if (page != None and size != None):
            select_query += f" OFFSET {int(page) * int(size)} ROWS FETCH NEXT {size} ROWS ONLY "

        conn = get_db_connection()
        cur = conn.cursor()
        cur.execute(select_query)
        activities = cur.fetchall()
        conn.close()

        return activities

    @staticmethod
    def find_by_id(activity_id: str):
        select_query = f"SELECT acs.*, acm.workload_unity FROM activities_submitted acs JOIN activities_metrics acm ON acs.kind = acm.kind WHERE acs.id = {activity_id} "

        conn = get_db_connection()
        cur = conn.cursor()
        cur.execute(select_query)
        activity = cur.fetchone()
        conn.close()

        return activity

    @staticmethod
    def count_by_owner_or_state(owner_email: str, states: list):
        select_query = " SELECT COUNT(*) FROM activities_submitted "
        if owner_email:
            select_query = f" owner_email = '{owner_email}' "
        
        if owner_email and states:
            select_query += " AND "
        elif states:
            select_query = " WHERE "

        if states:
            for i, s in enumerate(states):
                if i == 0:
                    select_query += f" state = '{s}' "
                else:
                    select_query += f" OR  state = '{s}' "

        conn = get_db_connection()
        cur = conn.cursor()
        cur.execute(select_query)
        activities = cur.fetchone()
        conn.close()

        return activities[0]

    @staticmethod
    def get_metrics():
        select_query = " SELECT * FROM activities_metrics; "

        conn = get_db_connection()
        cur = conn.cursor()
        cur.execute(select_query)
        metrics = cur.fetchall()
        conn.close()

        return metrics


